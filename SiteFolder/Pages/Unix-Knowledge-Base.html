<h1>Unix Quick Start (WIPâ€¦)</h1>
<h2>Intro</h2>
<p><strong>To test shell scripting there are these options (that I know of):</strong></p>
<ol>
    <li>Have a pc with Linux <strong>operating system (OP)</strong></li>
    <li>Use <strong>Vagrant</strong> (<a href="https://www.vagrantup.com/intro/getting-started/index.html">link for the tutorial here</a>) or a <strong>virtual machine</strong> with a Linux OP</li>
    <li>Use <strong>git Bash</strong></li>
    <li>Search on google keywords: <strong>shell or bash script online</strong></li>
</ol>
<p>If you have <strong>Windows (OP)</strong> and want rapidly to test shell scripting you can start with options <strong>4(simple stuff only)</strong> and <strong>3(more powerful)</strong>.But if you want to go deeper into Unix knowledge, better solutions are <strong>1</strong> and <strong>2</strong></p>
<h2>Basics</h2>
<p>In this example you can use a <strong>linux OP PC</strong>, <strong>Virtual Machine</strong> or <strong>git Bash</strong> program.</p>
<ul>
    <li>Open a command line terminal</li>
    <li>For instance with <strong>git Bash</strong> right click with mouse and select <strong>Git Bash Here</strong> option</li>
    <li><img src="SiteFolder/Images/Unix-Knowledge-Base/1.PNG" style="width: 100%"></li>
    <li>Now execute command <strong>pwd</strong> to show current directory</li>
    <li><img src="SiteFolder/Images/Unix-Knowledge-Base/2.PNG" style="width: 100%"></li>
    <li>To change directory write the following command: <strong>cd &lt;directory path&gt;</strong></li>
    <li><img src="SiteFolder/Images/Unix-Knowledge-Base/3.PNG" style="width: 100%"></li>
    <li>In the previous example changed directory from actual user home directory (represented by ~) and moved to Desktop</li>
    <li> To be even easier to navigate between directories use the <strong>tab button</strong> (on pc) for the terminal to suggest possible options</li>
    <li>To list folders and files from current directory use commands: <strong>ll</strong> or <strong>ls</strong></li>
    <li><img src="SiteFolder/Images/Unix-Knowledge-Base/4.PNG" style="width: 100%"></li>
    <li>Now let us create a folder (use <strong>mkdir</strong> command) to practice shell scripting there. Follow the following commands to do it:</li>
    <li><img src="SiteFolder/Images/Unix-Knowledge-Base/5_2.PNG" style="width: 100%"></li>
    <li>As you can see the folder is empty. So, to create a file just execute the following command: <strong>touch test</strong></li>
    <li><img src="SiteFolder/Images/Unix-Knowledge-Base/6.PNG" style="width: 100%"></li>
    <li>To edit file use unix file editor <strong>vi</strong> or <strong>vim</strong></li>
    <li>This editor is difficult to use, so here I will just be covering a simple example. For more, better search online.</li>
    <li id="vi vim">Write <strong>vi</strong> or <strong>vim</strong> and then the file you want to edit:</li>
    <li><img src="SiteFolder/Images/Unix-Knowledge-Base/7.PNG" style="width: 100%"></li>
    <li>A weird interce will appear</li>
    <li><img src="SiteFolder/Images/Unix-Knowledge-Base/8.PNG" style="width: 100%"></li>
    <li>Now to start writing press <b>i</b> and it will appear the following:</li>
    <li><img src="SiteFolder/Images/Unix-Knowledge-Base/9.PNG" style="width: 100%"></li>
    <li>Now you can edit the file</li>
    <li><img src="SiteFolder/Images/Unix-Knowledge-Base/10.PNG" style="width: 100%"></li>
    <li>To save the file press <b>ESC</b> key and then <b>:w</b> followed by an <b>Enter</b></li>
    <li><img src="SiteFolder/Images/Unix-Knowledge-Base/11.PNG" style="width: 50%;height: 350px;"></li>
    <li>Now you can exit the file and enter again and the <b>"Hello World"</b> will still be there</li>
    <li>To exit file just press <b>:q</b> followed by an <b>Enter</b></li>
    <li>Now if you use the command <b>cat</b> on the file</li>
    <li><img src="SiteFolder/Images/Unix-Knowledge-Base/12.PNG" style="width: 100%;"></li>
    <li>This command <b>prints</b> the file <b>content</b></li>

</ul>
<p>So these are just some basic commands to move around. To see more advance knowledge see the next chapter (Shell Script KnowledgeBase).</p>
<h1>Shell Script KnowledgeBase (WIP...)</h1>
<h2>Usefull Commands Cheat Sheet</h2>
<h3>Change Directory (cd)</h3>
<p>
    The command is <strong>cd &lt;dir or path&gt;</strong>.<br>
    If you press just the command <b>cd</b> with nothing more it will go to <b>user home directory</b>.
    <br>
    <br>
    <b>Example:</b><br><br>
    <img src="SiteFolder/Images/Unix-Knowledge-Base/13.PNG" style="width: 100%;">
</p>
<h3>Show files and folders list</h3>
<p>The commands are:</p>
<ul>
    <li><strong>ll &lt;dir or path&gt;</strong></li>
    <li><strong>ls &lt;dir or path&gt;</strong></li>
</ul>
<p>Examples:</p>
<ul>
    <li><strong>ll /x/y/z...</strong></li>
    <li><strong>ls ~/x/y/z...</strong></li>
</ul>

<h3>Check Space</h3>
<p>Generic commands:</p>

<ul>
    <li><strong>df -h &lt;dir or path&gt;</strong> -> shows space usage/left in folder/path</li>
    <li><strong>du -h &lt;dir or path&gt;</strong> -> list folders/files and their space occupied in folder/path</li>
    <li><strong>du -hs ./*|sort -h</strong> -> list files from smaller to bigger from current directory (./* or *)</li>
</ul>
<h3>Show File Content</h3>
<p>
    cat &lt;filename&gt;
</p>
<p><strong>Example:</strong></p>
<ul>
    <li>Create text file with <b>Hello World</b></li>
    <li><img src="SiteFolder/Images/Unix-Knowledge-Base/14.png" style="width: 100%;"></li>
    <li>cat output:</li>
    <li><img src="SiteFolder/Images/Unix-Knowledge-Base/15.png" style="width: 100%;"></li>
</ul>
<h3>Edit file</h3>
<p>Go check previous chapter <a href="#vi vim">Here</a></p>
<p>To delete all file content in <b>vim</b> write <b>gg</b> to go to the begining of the file and then write <b>dG</b> to clear all file content </p>
<p>To paste into <b>vim</b> click <b>shift+insert</b> and to copy content from <b>vim</b> select content using mouse (just that it copies directly to clipboard)</p>
<h3>Find Big Small files</h3>
<p>
    find . -type f -size +1M # find files bigger than 1 MegaByte in current directory
    <br>find . -type f -size -1M # find files smaller than 1 MegaByte in current directory
    <br># k -> kilo; M -> Mega; G ->Giga bytes</p>
<h3>Get actual directory of script</h3>
<xmp>DIR="$( cd "$( dirname "${BASH:SOURCE[0]}" )")" >/dev/null 2>&1 && pwd )"
echo $DIR
</xmp>
<h3>Get file name</h3>
<xmp>
filename=$(basename $0)
echo $filename
</xmp>
<h3>Align csv file</h3>

<p>having origin.csv file like:</p>
<xmp>
AAAAAAAAAAAAAA,BBBB,CCCCCCC
123,rsdfvsdf,0.334445456
1235,sovhjowihjw,0.12434
11,rsdsd,0.65783749384
12,sdihfosdifhsp,0.0893534785
</xmp>
<p>You can turn to target.csv file like:</p>

<xmp>    
AAAAAAAAAAAAAA ,BBBB          ,CCCCCCC
123            ,rsdfvsdf      ,0.334445456
1235           ,sovhjowihjw   ,0.12434
11             ,rsdsd         ,0.65783749384
12             ,sdihfosdifhsp ,0.0893534785
</xmp>
<p>Using command:</p>
    
<xmp>sed 's/,/:,/g' origin.csv | column -t -s: | sed 's/ ,/,/g' > target.csv # search online align csv bash </xmp>
<p>Check explanation <a href="https://stackoverflow.com/questions/51471554/align-columns-in-comma-separated-file"> Here</a></p>
<p>It is possible to do the same with other delimiters, just replace <b>','</b> with <b>'|'</b> beware is if the csv has <b>':'</b> if you are using this command. In that case use other character than <b>':'</b> you can use even an invented code word</p>
<h3>List only files command</h3>
<xmp>
ls -p | grep -v / # ls only on files
</xmp>
<h3>List only folders or directories</h3>
<xmp>
ls -d */ 
</xmp>
<h3>List files with excluding some</h3>
<xmp>ls -I "*.txt" # exclude txt files </xmp>
<h2>Variables</h2>
<h3>Declaration</h3>
<xmp>
# simple variable
x=12
echo $x

#String
str="Hi how are you"
echo $str

</xmp>
<h3>Calculations (Sum subtractand more)</h3>
<xmp>
# sum
echo $(expr 1 + 2 )
echo $(( 2 + 2 ))
# subtract
echo $(expr 1 - 2 )
# multiplication
echo $(expr 3 * 3 )
# integer division
echo $(expr  9 / 2 )
# decimal division
echo $(echo "scale=2; 9 / 2"| bc)

# with variables 
x=1
y=2
echo $(expr $x + $y )
echo $(( x + y ))
</xmp>
<h3>Operation to variable</h3>
<xmp>
res=$(( 3 + 3 ))
echo $res
</xmp>
<p>Other example</p>
<xmp>
#list files for folder
list=$(ls) #list of files in current folder
for file in ${list[@]};do
    echo $file
done   
</xmp>
<h2>If and else</h2>
<h3>Basic If</h3>
<xmp>
# basic if
var="AAA"
if [ $var = "AAA" ];then
    echo "var is AAA!"
fi

</xmp>
<h3>Else</h3>
<xmp>
var="AAA"
if [ $var = "AAA" ];then
    echo "var is AAA!"
else
echo "var is not AAA"
fi
</xmp>
<h3>Check if empty</h3>
<xmp>
#
if [ -z $var ];then
    echo "var is empty!"
else
    echo "var is $var"
fi
</xmp>
<h3>Negation</h3>
<xmp>
#
var="AAA"
if [ ! -z $var ];then
    echo "var is $var"
else
    echo "var is empty"
fi
</xmp>
<h3>elif</h3>
<xmp>
#
var="zzz"
if [ -z $var ];then
    echo "var is empty"
else
    echo "var is $var"
    if [ $var = "AAA" ];then
        echo "AAA -> 111"
    elif [ $var = "BBB" ];then
        echo "BBB -> 222"
    elif [ $var = "zzz" ];then
        echo "zzz -> 333"
    fi
fi
</xmp>
<h3>And and Or operations</h3>
<xmp>
z=""
a=""
    
if [ -z $z ] && [ -z $a ];then #if z and a empty
    echo "both empty"
elif [ -z $z ] || [ -z $a ];then #if z or a empty
    echo "one of them  is empty"
fi

</xmp>

<h2>Cycles and Arrays</h2>
<h3>Basic For</h3>
<xmp>
#Run through array and print each element
array=( "AAA" "BBB" "CCC" "DDD" )
for element in ${array[@]};do
echo $element
done
</xmp>
<h3>For with index</h3>
<xmp>
a=( aaa sss ddd fff )

# -> create a sequence from 0 to array length
for i in $(seq 0 ${#a[@]});do 
    echo "$i: ${a[$i]}"
done
echo "------------------------"
# -> create a sequence from 0 to array length-1
for i in $(seq 0 $(echo ${#a[@]} - 1|bc));do 
    echo "$i: ${a[$i]}"
done
echo "------------------------"
# -> Best way to create a sequence from 0 to array length-1
for i in ${!a[@]};do 
    echo "$i: ${a[$i]}"
done 

echo "------------------------"
echo "#a[@] = ${#a[@]}"
echo "a[@] = ${a[@]}"
echo "!a[@] = ${!a[@]}"
echo "a[0] | a[1] = ${a[0]}| ${a[1]}"
echo "a[*] = ${a[*]}"
echo "* = @"  
</xmp>
<h3>Append array</h3>
<xmp>
a=()
a+=(aaa)
a+=(bbb)
a+=(ccc)

for el in ${a[@]};do
    echo $el
done

</xmp>
<h3>While</h3>
<xmp>
index=0
array=("fj1" "sdjk2" "b3" "b4")
# while index lower than array length
while [ $index -lt ${#array[*]} ]
do
   echo "$index : ${array[$index]}"
   index=`expr $index + 1`
done


echo "---------------"
#invert order
index=${#array[*]}
# while index greater or equal to zero
while [ $index -ge 0 ]
do
   echo "$index : ${array[$index]}"
   index=`expr $index - 1`
done


#Output
#0 : fj1
#1 : sdjk2
#2 : b3
#3 : b4
#---------------
#4 : 
#3 : b4
#2 : b3
#1 : sdjk2
#0 : fj1
</xmp>
<h2>Hash Maps or Dictionary</h2>
<p>See link:<a href="https://stackoverflow.com/questions/1494178/how-to-define-hash-tables-in-bash" >Here!</a> (stackoverflow)</p>
<xmp>
declare -A animals
animals=( ["moo"]="cow" ["woof"]="dog")
echo "${animals[moo]}"
for sound in "${!animals[@]}"; do # ${!animals[@]} list keys of map; ${animals[@]} -> list values of map
	echo "$sound - ${animals[$sound]}"
done
</xmp>
<h2>Functions</h2>
<h3>Print menu function</h3>
<xmp>
menu(){
  local foo=""
  foo="$foo 1. list kafka topics\n"
  foo="$foo 2. read kafka topic\n"
  foo="$foo 3. search kafka topic\n"
  foo="$foo 4. show zookeeper hosts\n"
  foo="$foo 5. show kafka brokers\n"
  foo="$foo Choose Option:\n"
  echo "$foo"
}
printf "$(menu)"
</xmp>
<h3>Function with input parameters</h3>
<xmp>
Hi(){
    echo "Hello $1"
}
str="Tiago!"
echo $(Hi $str)
echo $(Hi "Pedro!")
    
</xmp>
<p><b>Concat function</b></p>
<xmp>
#Concat
concat_with_underscore(){
    
    echo "$1_$2"
}
echo $(concat_with_underscore "Hello" "World")
</xmp>
<h3>Function which receives array as input</h3>
<p>Source: <a href="https://stackoverflow.com/questions/1063347/passing-arrays-as-parameters-in-bash"> Here!</a> (stackoverflow)</p>
<xmp>
copyFiles(){
    argAry1=("${!1}")
    #argAry2=("${!2}") for a second array
   for el in "${argAry1[@]}";do
        echo "$el"
   done
   

}

array=("one" "two" "three")

copyFiles array[@]
</xmp>
<h3>Function which returns array (Split function)</h3>
<xmp>
#split function
split(){
    string="$1"
    split_regex="$2"
    # if inputs not empty
	if [ ! -z "$1" ] && [ ! -z "$2" ];then
		IFS="$split_regex" read -r -a array <<< "$string"
		echo "${array[@]}"
	else
		echo "at least one input is empty"
	fi
}
# echo the output of function
echo $(split "aa,bb,ccc,ddd" "," )
echo "----------------------"
# print each word in loop
for word in $(split "aa,bb,ccc,ddd" "," );do
	echo $word
done   
</xmp>
<p><b>Output</b></p>    
<xmp>
aa bb ccc ddd
----------------------
aa
bb
ccc
ddd
</xmp>
<h2>String Manipulation</h2>
<h3>String Replace</h3>
<p>
    foo="2019-04-24"
    <br>
    <br># replace first "-" only with "."
    <br>bar=${foo/-/.}
    <br>echo $bar
    <br>
    <br># replace all "-"
    <br>bar=${foo//-/.}
    <br>echo $bar

</p>
<p><strong>Other Way:</strong></p>
<p>
    echo " yaay ss "|sed 's/ /z/g' # output: zyaayzssz
    <br>echo " yaay ss "|sed 's/ /z/' # output: zyaay ss
</p>
<p><strong>On a file</strong></p>
<p>sed -i "s/a/_/g" &lt;filename&gt; # replace all 'a' by '_' in file...
</p>
<p>See <a href="http://tldp.org/LDP/abs/html/string-manipulation.html">this site</a> for more details.</p> 
<h3>Split Function</h3>
<xmp>
#split function
split(){
    string="$1"
    split_regex="$2"
    # if inputs not empty
	if [ ! -z "$1" ] && [ ! -z "$2" ];then
		IFS="$split_regex" read -r -a array <<< "$string"
		echo "${array[@]}"
	else
		echo "at least one input is empty"
	fi
}
# echo the output of function
echo $(split "aa,bb,ccc,ddd" "," )
echo "----------------------"
# print each word in loop
for word in $(split "aa,bb,ccc,ddd" "," );do
	echo $word
done   
</xmp>
<p><b>Output</b></p>    
<xmp>
aa bb ccc ddd
----------------------
aa
bb
ccc
ddd
</xmp>
<h3>Trim</h3>
<xmp>
echo '"aaa"'|tr -d \" #output: aaa
echo '!aaa!'|tr -d \! #output: aaa
echo 'yaaay'|tr -d y #output: aaa
echo ' aaa ss '|tr -d ' ' #output: aaass
echo ' aaa ss '|sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' #output: aaa ss        
</xmp>    
<h2>Dates manipulation</h2>
<h3>Get date</h3>
<xmp>
    DATE1=$(date +%Y-%m-%d)
    DATE2=$(date +%Y%m%d)
    echo "$DATE1"
    echo "$DATE2"
    echo $(date +%Y-%m-%d-%H:%M:%S)
</xmp>    
<h3>Change Date Format</h3>
<xmp>
received_date=$(date +%Y%m%d)    
valid_date=$(date "+%Y-%m-%d" -d "$1" 2>/dev/null) #if is valid $report_date gets date with the valid format else empty string.

if [ -z $valid_date ]; then
	echo "not valid date"
else
	echo OK
fi
echo "valid_date: $valid_date || received_date: $received_date"    
</xmp>
<h3>Get first and last day of the month</h3> 
<xmp>
month=0 # 0=current , -1=previous month, 1=next month ,2...
START_LAST_MONTH=$(date "+%Y-%m-01" -d "$month Month");
END_LAST_MONTH=$(date "+%Y-%m-%d" -d "$START_LAST_MONTH +1 month -1 day");

#Test Code
echo START_LAST_MONTH=$START_LAST_MONTH
echo END_LAST_MONTH=$END_LAST_MONTH
</xmp>
<h3>Dates calculations</h3>
<xmp>
d=$(date  +%Y-%m-%d) # actual date
d_diff=30

echo $(date --date="${d} -${d_diff} day" +%Y-%m-%d)    
    
</xmp>
<h2>...</h2>    
